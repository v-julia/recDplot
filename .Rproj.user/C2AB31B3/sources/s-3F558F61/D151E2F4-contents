---
title: "Recombination in Hepadnaviruses"
author: "Yulia Vakulenko"
date: '19 June 2019'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Exploratory analysis of recombination in Hepadnaviruses

This notebook presents the results of RDP4 analysis of Human Hepatitits B viruses (HBV) and bat HBV.

Sequences of HBV genotypes A, B, C, D, E, F, G, H were downloaded from HBV database https://hbvdb.ibcp.fr/HBVdb/. Then they were processed using script change_id.py which changes name of each sequence to the following "AccessionNUmber_HBV_Genotype".

Then sequences of each genotype were aligned
using remove_similar_seq.py script to remove sequences which nucleotide pairwise identity score is higher than 99%. 

###### The python functions for parsing RDP4 output
```{python}
import numpy
import re
import pandas as pd

#dictionary with host_names
animals = {
    'Unknown':'unknown',
    'H.pomona' :'H.pom(RBHBV)',
    'H.larvatus' :'H.larv(RBHBV)',
    'H.armiger' :'H.arm(RBHBV)',
    'H.cf.ruber' :'H.cf.ruber(RBHBV)',
    'R.luctus' :'R.luct(HBHBV)',
    'R.monoceros' :'R.mon(HBHBV)',
    'R.pusillus' :'R.pu(HBHBV)',
    'R.ferrumequinum' :'R.fer(HBHBV)',
    'R.alcyone' :'R.alc(HBHBV)',
    'R.sinicus' :'R.sin(HBHBV)',
    'R.pearsonii' :'R.pear(HBHBV)',
    'M.schreibersii' :'M.schr(LBHBV)',
    'M.fuliginosus' :'M.ful(LBHBV)',
    'M.chinensis' :'M.chi(LBHBV)',
    'M.davidii' :'M.dav',
    'U.bilobatum' :'U.bil(TBHBV)',
    'Duiker' :'Duiker',
    'Gibbon' :'Gibbon',
    'Gorilla' :'Gorilla',
    'Chimp' :'Chimp',
    'GtA' :'GtA',
    'GtB' :'GtB',
    'GtC' :'GtC',
    'GtD' :'GtD',
    'GtE' :'GtE',
    'GtF' :'GtF',
    'GtG' :'GtG',
    'GtH' :'GtH',
    'CMHBV' :'capuchin',
    'WMHBV' :'woolly_monkey',
    'Crocidura' :'Crocidura',
    'Sorex' :'Sorex',
    'ASHV' :'arctic_squirrel',
    'GSHV' :'ground_squirrel',
    'WHV' :'woodchuck',
    'woodchuck' :'woodchuck'
}
animals1 = {
    'Unknown':'unknown',
    'H.pomona' :'bat_ow',
    'H.larvatus' :'bat_ow',
    'H.armiger' :'bat_ow',
    'R.luctus' :'bat_ow',
    'R.monoceros' :'bat_ow',
    'R.pusillus' :'bat_ow',
    'R.ferrumequinum' :'bat_ow',
    'R.alcyone' :'bat_ow',
    'R.sinicus' :'bat_ow',
    'R.pearsonii' :'bat_ow',
    'M.schreibersii' :'bat_ow',
    'M.fuliginosus' :'bat_ow',
    'M.chinensis' :'bat_ow',
    'M.davidii' :'bat_ow',
    'U.bilobatum' :'bat_nw',
    'H.cf.ruber' :'bat_ow',
    'Duiker' :'Duiker',
    'Gibbon' :'Gibbon',
    'Gorilla' :'Gorilla',
    'Chimp' :'Chimp',
    'GtA' :'GtA',
    'GtB' :'GtB',
    'GtC' :'GtC',
    'GtD' :'GtD',
    'GtE' :'GtE',
    'GtF' :'GtF',
    'GtG' :'GtG',
    'GtH' :'GtH',
    'CMHBV' :'capuchin',
    'WMHBV' :'woolly_monkey',
    'Crocidura' :'Crocidura',
    'Sorex' :'Sorex',
    'ASHV' :'arctic_squirrel',
    'GSHV' :'ground_squirrel',
    'WHV' :'woodchuck',
    'woodchuck' :'woodchuck'
}

# finds host name (keys in animals) in string
def find_host(stri):
    m = [animals[key] for key in animals.keys() if re.findall(key, stri)][0]
    return m
    
# for each recombination event in csv output file from RDP4 extracts 
# serial number, start and end position of recombinant fragment, number of recombination events detected,
# number of methods that support the event, hosts of parental and recombination sequences.
# returns dictionary
def rdp4_to_dict(input_file):

  #dictionary for output table
  rdp4_dict = {
      'start' : [],
      'end' : [],
      'event number':[],
      'number of events' : [],
      'number of methods': [],
      'recomb type': []
      }
  
  with open(input_file, 'r') as rdp4_file:
      events_count = 0 # serial number of event
      current_rec = 0 # serial number current recombination event
      sure = 0 # event is supported by at least two methods
      
      for line in rdp4_file.readlines()[3:]: #the first three lines are ommited
          if line.startswith('Table'): # Table key section
              break
          if line == '\n':
              if sure == 1:
                  rdp4_dict['number of events'].append(events_count)
              continue
              
          line_l = line.split(',')
          if current_rec != line_l[0].strip(): # line for new event

              current_rec = line_l[0].strip()
              
              if (9-line_l[11:].count('NS')) <2 : #check the number of methods supporting the event
                  sure = 0
                  continue
              else:
                  sure = 1
                  events_count = 1
                  rdp4_dict['event number'].append(current_rec)
                  rdp4_dict['start'].append(int(line_l[2].strip('*')))
                  rdp4_dict['end'].append(int(line_l[3].strip('*')))
                  rdp4_dict['number of methods'].append(str(9-line_l[11:].count('NS')))
                  rdp4_dict['recomb type'].append(find_host(line_l[8])+'='+ find_host(line_l[9])+'+'+find_host(line_l[10]))
  
          else:
              #if line_l[8] != '' and sure == 1:
              if sure == 1:
                  events_count += 1
  #print(rdp4_dict)
  return rdp4_dict


```

#### Distribution of recombinant fragments in HBV (1% threshold) identified by RDP4


```{python, echo=T, message=F, warning=F}

import pandas as pd

filename = "D:/DATA/Hepadnaviridae/human1.csv"

rdp4_dict = rdp4_to_dict(filename)
pd.DataFrame.from_dict(rdp4_dict).to_csv(filename.replace(".csv","_table.csv"))

```

```{r, echo=T}
library(reticulate)
library(ggplot2)

filename = "D:/DATA/Hepadnaviridae/human1.csv"
#rdp4_table = data.frame(py$rdp4_dict)
rdp4_table = read.table(gsub(".csv", "_table.csv", filename), sep=",", header = TRUE)
rdp4_table = cbind(rdp4_table, y = rep(seq(4,10,length.out =nrow(rdp4_table))))


plot_segment = function(df, genome_length) {
  g = ggplot() +
    geom_segment(data=df, aes(x=start, y = y, xend = end, yend = y, col=recomb.type)) +
    xlim(c(0, genome_length)) +  ylim(c(0, 10)) + 
    labs(y="", x="Position in genome", title="Distribution of recombination fragments in HBV (1%)") +
    theme(axis.text.y = element_blank(), axis.ticks.y = element_blank()) 
  
  return(g)
}

g = plot_segment(rdp4_table, 3631) 

g1 = g + geom_segment(aes(x = 1, y = 1, xend = 731, yend = 1), arrow = arrow(length = unit(0.1, "cm"))) + 
  geom_label(aes(label="S", x=400, y=1.2)) +
  
  geom_segment(aes(x = 2987, y = 1, xend = 3631, yend = 1)) + 
  geom_label(aes(label="S", x=3300, y=1.2)) +
  
  geom_segment(aes(x = 1269, y = 1.5, xend = 1893, yend = 1.5),arrow = arrow(length = unit(0.1, "cm")))+
  geom_label(aes(label="X", x=1500, y=1.7)) +
  
  geom_segment(aes(x = 1812, y = 2, xend = 2588, yend = 2),arrow = arrow(length = unit(0.1, "cm"))) + 
  geom_label(aes(label="C", x=2000, y=2.2)) +
  
  geom_segment(aes(x = 2404, y = 3, xend = 3631, yend = 3)) +
  geom_label(aes(label="P", x=3100, y=3.2)) +
  
  geom_segment(aes(x = 1, y = 3, xend = 1528, yend = 3),arrow = arrow(length = unit(0.1, "cm"))) +
  geom_label(aes(label="P", x=500, y=3.2))
g1

```

######  Functions for drawing pairwise distance comparison plots

```{r,  message=F, warning=F}
library("spider")
library("ape")
library("seqinr")
#library("gridExtra")
#library(hexbin)
#library(grid)
library(ggplot2)
library(sjstats)
library(gplots)
library(colorRamps)

# Function plots pairwise nucleotide distance comparison plot.
# Each dot corresponds to a pair of nucleotide distances between 
# the same pair of genomes in two genomic regions - odd sites and even sites of genome (see axis).
# Returns list with ggplot, matrices of distances between pairs of seqences calculated for 
# odd and even sites

plot_control = function(dna_object){
  
  # subalignments for odd and even sites
  al_odd=dna_object[1:length(dna_object[,1]), seq(from = 1, to = length(dna_object[1,]), by=2)]
  al_even=dna_object[1:length(dna_object[,1]), seq(from = 2, to = length(dna_object[1,]), by=2)]
  
  # distance matrices for each region
  dna_sl_dist1 <-dist.gene(al_odd, method = "percentage",  pairwise.deletion = TRUE)
  dna_sl_dist2 <-dist.gene(al_even, method = "percentage",  pairwise.deletion = TRUE)
  
  # adding random noise to distances matrices' values
  dist1= as.vector(dna_sl_dist1) + rnorm(length(dna_sl_dist1),mean = 0,sd= 0.001)
  dist2= as.vector(dna_sl_dist2) + rnorm(length(dna_sl_dist2),mean = 0,sd= 0.0001)
  
  # pairwise nucleotide distance comparison plot
  dist_plot=ggplot(data.frame(dist1,dist2),aes(dist1,dist2))+stat_bin2d(binwidth = 0.001)+ 
    scale_fill_gradientn(colours=c("blue","red"))+ theme(legend.justification=c(1,0), legend.position=c(1,0))+
    xlab("odd sites")+ylab("even sites")
  #+  geom_smooth(method='lm',formula=y~x)
  
  return(list(dist_plot, dna_sl_dist1, dna_sl_dist2))
  
}

# Function plots pairwise nucleotide distance comparison plot.
# Each dot corresponds to a pair of nucleotide distances between 
# the same pair of genomes in two genomic regions - st1-e1 and st2-e2 (see axis).
# Returns list with ggplot, matrices of distances between pairs of seqences calculated for 
# st1-e1 and st2-e2 regions

plot_dist_test = function(dna_object, st1,e1,st2,e2){
  
  # subalignments for st1-e1 and st2-e2 regions
  dna_sl1=dna_object[1:length(dna_object[,1]), seq(from = st1, to = e1, by=1)]
  dna_sl2=dna_object[1:length(dna_object[,1]), seq(from = st2, to = e2, by=1)]
  
  # distance matrices for each region
  dna_sl_dist1 <-dist.gene(dna_sl1, method = "percentage",  pairwise.deletion = TRUE)
  dna_sl_dist2 <-dist.gene(dna_sl2, method = "percentage",  pairwise.deletion = TRUE)
  #HepadnaDist1 <-dist.dna(Hepadna1, as.matrix = TRUE, model = "JC69")
  #HepadnaDist4 <-dist.dna(Hepadna4, as.matrix = TRUE, model = "JC69")
  
  # adding random noise to distances matrices' values
  dist1= as.vector(dna_sl_dist1) + rnorm(length(dna_sl_dist1),mean = 0,sd= 0.001)
  dist2= as.vector(dna_sl_dist2) + rnorm(length(dna_sl_dist2),mean = 0,sd= 0.001)
  
  #Hepadna1=abs(rnorm(HepadnaDist1[lower.tri(HepadnaDist1,diag = FALSE)], mean=HepadnaDist1[lower.tri(HepadnaDist1,diag = FALSE)], sd = 0))
  #Hepadna4=abs(rnorm(HepadnaDist4[lower.tri(HepadnaDist4,diag = FALSE)], mean=HepadnaDist4[lower.tri(HepadnaDist4,diag = FALSE)], sd = 0))
  
  
  # pairwise nucleotide distance comparison plot
  dist_plot=ggplot(data.frame(dist1,dist2),aes(dist1,dist2))+stat_bin2d(binwidth = 0.003)+ 
    scale_fill_gradientn(colours=c("blue","red"))+ theme(legend.justification=c(1,0), legend.position=c(1,0))+
    xlab(paste(toString(st1),toString(e1),sep=":"))+ylab(paste(toString(st2),toString(e2),sep=":"))
  #+  geom_smooth(method='lm',formula=y~x)
  
  return(list(dist_plot, dna_sl_dist1, dna_sl_dist2))
  
}

# Prints names of sequences pairs which pairwise nucleotide distances lay between 
# val11-val12 in genomic region 1 and val21-val22 in genomic region 2/
# distM1 - distance matrix built for region 1
# distM2 - distance matrix built for region 2
# Prints strings "name1\tname2\tdistance_in_region1\tdistance_in_region2"
find_recomb_names <- function(distM1, val11, val12, distM2, val21, val22){
  
  
  #distM1 = as.matrix(l3[[2]])
  #distM2 = as.matrix(l3[[3]])
  
  #val11 = 0.4
  #val12 = 0.6
    
  #val21 = 0.4
  #val22 = 0.6
  
  
  #positions of matrix for region 1 with values between val11 and val12
  b1 = find_dist_slice(distM1,val11, val12)
  #positions of matrix for region 2 with values between val21 and val22
  b2 = find_dist_slice(distM2,val21, val22)
  #intersection of b1 and b2
  b= intersect(b1,b2)
  len_b = length(distM1[1,])
  
  #returns positions of rows in matrix
  r = sapply(b,function(x){if(x%%len_b==0){return(len_b)} else{return(x%%len_b)}})
  #returns positions of columns in matrix
  c = sapply(b,function(x){if(x%%len_b==0){return(x%/%len_b)} else{return(x%/%len_b+1)}})
  
  #values of rows and columns
  c_names <- sapply(c,function(x) {colnames(distM1)[x]})
  r_names <- sapply(r,function(x) {rownames(distM1)[x]})
  
  #print(c_names)
  #print(r_names)
  df = cbind(c_names,r_names)
  
  #sorts names in alphabetical order
  sort_str = function(x){
    if (x["c_names"]>x["r_names"]) return(as.vector(x))
    else {return(c(x["r_names"],x["c_names"]))}
  }
  
  sorted = data.frame(unique(t(apply(df,1,sort_str))),stringsAsFactors = FALSE)
  colnames(sorted) = c(1,2)
  #  values in matrices
  x = apply(sorted, 1, function(x){distM1[which(rownames(distM1) == x[1]),which(colnames(distM1) == x[2])]})
  y = apply(sorted, 1, function(x){distM2[which(rownames(distM1) == x[1]),which(colnames(distM1) == x[2])]})
  sorted = cbind(sorted,x,y)

  
  return(sorted)
  
}

#returns positions in matrix which values are between val1 and val2
find_dist_slice<-function(distM, val1, val2){
  b = which((distM>=val1)&(distM<=val2))
  #print(which((distM>val1)&(distM<val2),arr.ind=T))
  return(b)
}

#plots pairwise distance comparison plots for different pairs of regions 
#dna_object - list of DNA sequences (class DNAbin)
#step - step for dna regions/ window for regions is equal to step
#method - method of calculation distances ("pdist", "JC", "Kimura", "TN")
#fig_dir - path to directory for saving figures
#name_fig - prefix for figure name

#created directory fig_dir/step and saves pairwise distance comparison plot there

plot_dist = function(dna_object, step, method, fig_dir, name_fig){
  
  length_aln = length(dna_object[1,]) #length of alignment
  num_seq = length(dna_object[,1]) # number od sequences in alignment
  starts = seq(from=1, to = length_aln, by = step) #start positions of regions 
  ends = seq(from=step, to = length_aln, by = step) #end positions of regions
  
  
  if (length_aln%%step>0){ends=c(ends,length_aln)}
  
  #positions of genomes regions
  df_intervals = cbind(starts,ends)
  
  #list with distance matrices for each region
  dist_matrices = list()
  for (i in 1:nrow(df_intervals)){
    #slice of alignment
    slice = dna_object[1:num_seq, seq(from = df_intervals[i,"starts"], to = df_intervals[i,"ends"], by=1)]
    #dist_matrices[[i]] = dist.dna(slice,  as.matrix = TRUE,  model = "JC69")
    
    #calculation of distance matrix
    if (method == "pdist"){dist_matrices[[i]] = dist.gene(slice, method = "percentage",  pairwise.deletion = TRUE)}
    else {
      if (method == "JC"){dist_matrices[[i]] = dist.dna(slice,  as.matrix = TRUE,  model = "JC69")}
      if (method == "Kimura"){dist_matrices[[i]] = dist.dna(slice,  as.matrix = TRUE,  model = "K80")}
      if (method == "TN"){dist_matrices[[i]] = dist.dna(slice,  as.matrix = TRUE,  model = "K80")}
      #else{print("Unknown method")}
    }
    
  }
  
  #list with ggplots of distance comparison plots for different pairs of regions
  ggplots = list()
  k=1
  for(i in 1:(nrow(df_intervals)-1)){
    for(j in (i+1):nrow(df_intervals)){
      #xlab name
      rname1 = paste(toString(df_intervals[i,"starts"]),"-",toString(df_intervals[i,"ends"]),sep="")
      #ylab name
      rname2 = paste(toString(df_intervals[j,"starts"]),"-",toString(df_intervals[j,"ends"]),sep="")
      #dist1 = dist_matrices[[i]][lower.tri(dist_matrices[[i]],diag = FALSE)]+ rnorm(length(dist_matrices[[i]][lower.tri(dist_matrices[[i]],diag = FALSE)]), mean=0, sd = 0.0001)
      #dist2 = dist_matrices[[j]][lower.tri(dist_matrices[[j]],diag = FALSE)]+ rnorm(length(dist_matrices[[j]][lower.tri(dist_matrices[[j]],diag = FALSE)]), mean=0, sd = 0.0001)
      
      #adding random noise to values 
      if (method == "pdist"){
        dist1 = as.vector(dist_matrices[[i]]+ rnorm(length(dist_matrices[[i]]), mean=0, sd = 0.0001))
        dist2 = as.vector(dist_matrices[[j]] + rnorm(length(dist_matrices[[j]]), mean=0, sd = 0.0001))
      }
      else{
        dist1 = dist_matrices[[i]][lower.tri(dist_matrices[[i]],diag = FALSE)]+ rnorm(length(dist_matrices[[i]][lower.tri(dist_matrices[[i]],diag = FALSE)]), mean=0, sd = 0.0001)
        dist2 = dist_matrices[[j]][lower.tri(dist_matrices[[j]],diag = FALSE)]+ rnorm(length(dist_matrices[[j]][lower.tri(dist_matrices[[j]],diag = FALSE)]), mean=0, sd = 0.0001)
        
      }
      
      ggplots[[k]] = ggplot(data.frame(dist1,dist2),aes(dist1,dist2))+
        stat_bin2d(binwidth = 0.005)+scale_fill_gradientn(colours=c("blue","red"))+
        theme(legend.justification=c(1,0), legend.position=c(1,0))+
        xlab(rname1)+ylab(rname2)
      ggsave(ggplots[[k]],file= paste(fig_dir,name_fig,rname1,"_",rname2,".png",sep="") )
      xirk=k+1
      
    }
  }
}

# plots heatmap with RMSE in pairwise distance comparison plot for each pair of genomic regions
# dna_object -  list of DNA sequences (class DNAbin)
# step 
# window - length of genomic regions to compare
# method - method of calculation distances ("pdist", "JC", "Kimura", "TN")
# modification - pairwise deletion of positions with gaps or not

#returns matrix with rmse values for each pair f=of genomic regions

plot_rmse = function(dna_object, step,window, method, modification=NA){

  length_aln = length(dna_object[1,]) #length of alignment
  num_seq = length(dna_object[,1]) # number of sequences in alignment
  
  starts = seq(from=0, to =length_aln-window, by = step) # start positions of genomic regions
  starts[1]=1
  ends = seq(from=window, to = length_aln, by = step) # end positions of genomic regions
  if (length_aln%%step>step){ends=c(ends,length_aln)}
  
  df_intervals = cbind(starts,ends) #intervals
  
  #names = apply(df_intervals, 1, function(x){paste(toString(x[1]),toString(x[2]),sep="_")})
  
  #dataframe to store RMSE values of each comparison
  rmse_df = data.frame(matrix(ncol=length(starts), nrow = length(starts))) 
  colnames(rmse_df)=starts
  rownames(rmse_df)=starts
  
  #list of distance matrices for each pair of genomic regions
  dist_matrices = list()
  for (i in 1:nrow(df_intervals)){
    slice = dna_object[1:num_seq, seq(from = df_intervals[i,"starts"], to = df_intervals[i,"ends"], by=1)]
    
    #dist_matrices[[i]] = dist.dna(slice,  as.matrix = TRUE,  model = "JC69")
    if (method == "pdist"){
      if (modification=="pairwise"){
        dist_matrices[[i]] = dist.gene(slice, method = "percentage",  pairwise.deletion = TRUE)}
      else {      
        dist_matrices[[i]] = dist.gene(slice, method = "percentage",  pairwise.deletion = FALSE)}
    }
    
    else {
      if (method == "JC"){dist_matrices[[i]] = dist.dna(slice,  as.matrix = TRUE,  model = "JC69")}
      if (method == "Kimura"){dist_matrices[[i]] = dist.dna(slice,  as.matrix = TRUE,  model = "K80")}
      if (method == "TN"){dist_matrices[[i]] = dist.dna(slice,  as.matrix = TRUE,  model = "K80")}
      #else{print("Unknown method")}
    }
    
  }
  print(length(dist_matrices))
  for (i in 1:nrow(df_intervals)){
    for (j in 1:nrow(df_intervals)){
      #fits pairwise distance comparison plots linear model, calculates rmse
      rmse_df[i,j] =rmse(lm(dist_matrices[[j]]~dist_matrices[[i]]))
    }
  }
  colnames(rmse_df)
  return(rmse_df)
  
}
```

######  Functions for drawing the distribution of host pairs in dots which deviate from regression line.

```{r}
library(scales)
#library("RColorBrewer")

#input is dataframe produced by find_recomb_names
#returns vector with percentage values of each host pair

pie_values = function(df_rec){
  
  pairs = apply(df_rec, 1, fetch_host_pair)
pairs_unique = unique(pairs)
values = sapply(pairs_unique, function(x) round(sum(pairs == x)*100/length(pairs), digits =2))
return(values)
  
}
 
animals_list <- c('Unknown' = 'Unknown',    'Unknown' = 'unknown',
    'H.pomona'  = 'H.pom(RBHBV)',
    'H.larvatus'  = 'H.larv(RBHBV)',
    'H.armiger'  = 'H.arm(RBHBV)',
    'H.cf.ruber'  = 'H.cf.ruber(RBHBV)',
    'R.luctus'  = 'R.luct(HBHBV)',
    'R.monoceros'  = 'R.mon(HBHBV)',
    'R.pusillus'  = 'R.pu(HBHBV)',
    'R.ferrumequinum'  = 'R.fer(HBHBV)',
    'R.alcyone'  = 'R.alc(HBHBV)',
    'R.sinicus'  = 'R.sin(HBHBV)',
    'R.pearsonii'  = 'R.pear(HBHBV)',
    'M.schreibersii'  = 'M.schr(LBHBV)',
    'M.fuliginosus'  = 'M.ful(LBHBV)',
    'M.chinensis'  = 'M.chi(LBHBV)',
    'M.davidii'  = 'M.dav',
    'U.bilobatum'  = 'U.bil(TBHBV)',
    'Duiker'  = 'Duiker',
    'Gibbon'  = 'Gibbon',
    'Gorilla'  = 'Gorilla',
    'Chimp'  = 'Chimp',
    'GtA'  = 'GtA',
    'GtB'  = 'GtB',
    'GtC'  = 'GtC',
    'GtD'  = 'GtD',
    'GtE'  = 'GtE',
    'GtF'  = 'GtF',
    'GtG'  = 'GtG',
    'GtH'  = 'GtH',
    'CMHBV'  = 'capuchin',
    'WMHBV'  = 'woolly_monkey',
    'Crocidura'  = 'Crocidura',
    'Sorex'  = 'Sorex',
    'ASHV'  = 'arctic_squirrel',
    'GSHV'  = 'ground_squirrel',
    'WHV'  = 'woodchuck',
    'woodchuck'  = 'woodchuck')

#input is a row in dataframe produced by find_recomb_names:
#SeqName1 SeqName2 ValueX ValueY
#SeqName = AccessionNumber_Virus_Host/position
#fetches Host value from SeqName1 and SeqName2, returns string #host1+host2#
fetch_host_pair = function(row){

  
  host1 = animals_list[[strsplit(strsplit(row[1], "_")[[1]][3],"/")[[1]][1]]]
  host2 = animals_list[[strsplit(strsplit(row[2], "_")[[1]][3],"/")[[1]][1]]]
  
  names = sort(c(host1,host2))
  return(paste(names[1],names[2],sep="+"))
  
}

plot_host_pie = function(matrix1, st1, e1, matrix2, st2, e2){
  df_rec = find_recomb_names(matrix1, st1, e1, matrix2, st2, e2)
  values = pie_values(df_rec)
  pie(values, labels = sapply(values, function(x) paste(x, "%")), main = paste("Host pairs in the region", st1, "-", e1, "and", st2, "-", e2, sep=" "),col = primary.colors(length(values)))
legend("topright", names(values), fill = primary.colors(length(values)))
}
 #   brewer.pal(length(values),name = 'RdBu')

#print("recombinants in 1400:1800 vs 2700 vs 3100")
#df_rec = find_recomb_names(as.matrix(l2[[2]]), 0.19, 0.3, as.matrix(l2[[3]]), 0.02, 0.3)
#values = pie_values(df_rec)
#pie(values, labels = sapply(values, function(x) paste(x, "%")), main = "Host pairs in the region 0.19-0.3 (1400-1800 nt) and 0.02-0.3 (2700-3100)",col = brewer.pal(length(values),name = 'RdBu'))
#legend("topright", names(values), fill = brewer.pal(length(values),name = 'RdBu'))


#pie_df = cbind(data.frame(values), names(values))
#colnames(pie_df)= c("value","hosts")
#pie = ggplot(pie_df, aes(x="", y=value, fill=hosts)) + geom_bar(width = 1, stat = "identity") +  coord_polar("y", start=0)
#pie + scale_fill_brewer() +
#  theme(axis.text.x=element_blank()) +
#  geom_text(aes(y = value/4 + c(0, cumsum(value)[-length(value)]), 
#            label = percent(value/100)), size=5)
```

### Compatibility matrices for HBV

#### Robinson-Foulds compatibility matrix

Robinson-Foulds compatibility matrix was calculated in RDP4 with window size = 400, step = 100.

```{r}
RF_bats_matrix = as.matrix(read.table("human1_rdp4_RFmatrix.csv", sep=","))

colnames(RF_bats_matrix) = seq(from = 0, by = 100, length.out = ncol(RF_bats_matrix))
colnames(RF_bats_matrix)[1]=1

rownames(RF_bats_matrix) = seq(from = 0, by = 100, length.out = nrow(RF_bats_matrix))
rownames(RF_bats_matrix)[1]=1

RF_bats_matrix = RF_bats_matrix[,1:(ncol(RF_bats_matrix)-2)][(nrow(RF_bats_matrix)-1):1,]

heatmap.2(RF_bats_matrix, Rowv = FALSE, Colv = "Rowv", dendrogram = 'none', col=matlab.like, tracecol=NA, main = "Robinson-Foulds compatibility matrix (window=400,step=100)")
```


#### RMSE compatibility matrix


```{r}
alignment = read.dna("D:/DATA/Hepadnaviridae/HBV_1_chn_aln.fas", format="fasta")
rmse_df = plot_rmse(alignment,25, 300,"pdist","pairwise")

```
```{r}
heatmap.2(as.matrix(rmse_df[nrow(rmse_df):1,]),Rowv = FALSE, Colv = "Rowv", dendrogram = 'none',col=matlab.like, main="HBV (1% threshold)",tracecol=NA)

```

#### Control pairwise distance plot

```{r}
contr = plot_control(alignment)
contr[[1]]
```

#### 500-800nt vs 1500-1800nt

```{r}
l = plot_dist_test(alignment, 500,800,1500,1800)
l[[1]]
```
```{r}
plot_host_pie(as.matrix(l[[2]]),0, 0.08, as.matrix(l[[3]]), 0.19, 0.3 )
plot_host_pie(as.matrix(l[[2]]),0.2, 0.25, as.matrix(l[[3]]), 0.08, 0.15 )
```

#### 1000-1700nt vs 1900-2200nt

```{r}
l1 = plot_dist_test(alignment, 1000,1700,1900,2200)
l1[[1]]
```
```{r}

plot_host_pie(as.matrix(l1[[2]]),0.2, 0.3, as.matrix(l1[[3]]), 0, 0.16)

plot_host_pie(as.matrix(l1[[2]]),0, 0.12, as.matrix(l1[[3]]), 0.2, 0.3 )
```

#### 1400-1800nt vs 2800-3100nt

```{r}
l2 = plot_dist_test(alignment, 1400,1800,2800,3100)
l2[[1]]
```

```{r}

plot_host_pie(as.matrix(l2[[2]]),0.2, 0.3, as.matrix(l2[[3]]), 0, 0.3)

plot_host_pie(as.matrix(l2[[2]]),0.2, 0.3, as.matrix(l2[[3]]), 0, 0.06 )
plot_host_pie(as.matrix(l2[[2]]),0.2, 0.3, as.matrix(l2[[3]]), 0.06, 0.15 )
plot_host_pie(as.matrix(l2[[2]]),0.2, 0.3, as.matrix(l2[[3]]), 0.15, 0.3 )
```

#### Recombination in bats

Parsing RDP4 output
```{python}
import numpy
import re
import pandas as pd


# finds host name (keys in animals) in string
def find_host(stri):
    m = [animals1[key] for key in animals1.keys() if re.findall(key, stri)][0]
    return m
    

filename = "D:/DATA/Hepadnaviridae/bats_rdp4.csv"

rdp4_dict = rdp4_to_dict(filename)
pd.DataFrame.from_dict(rdp4_dict).to_csv(filename.replace(".csv","_table.csv"))

```

```{r, echo=T}
library(reticulate)
library(ggplot2)

filename = "D:/DATA/Hepadnaviridae/bats_rdp4.csv"
#rdp4_table = data.frame(py$rdp4_dict)
rdp4_table = read.table(gsub(".csv", "_table.csv", filename), sep=",", header = TRUE)
rdp4_table = cbind(rdp4_table, y = rep(seq(4,10,length.out =nrow(rdp4_table))))


plot_segment = function(df, genome_length) {
  g = ggplot() +
    geom_segment(data=df, aes(x=start, y = y, xend = end, yend = y, col=recomb.type)) +
    xlim(c(0, genome_length)) +  ylim(c(0, 10)) + 
    labs(y="", x="Position in genome", title="Distribution of recombination fragmnets in bats HBV") +
    theme(axis.text.y = element_blank(), axis.ticks.y = element_blank()) 
  
  return(g)
}

g = plot_segment(rdp4_table, 3631) 

g1 = g + geom_segment(aes(x = 1, y = 1, xend = 675, yend = 1), arrow = arrow(length = unit(0.1, "cm"))) + 
  geom_label(aes(label="S", x=350, y=1.2)) +
  
  geom_segment(aes(x = 2737, y = 1, xend = 3494, yend = 1)) + 
  geom_label(aes(label="S", x=3300, y=1.2)) +
  
  geom_segment(aes(x = 1220, y = 1.5, xend = 1655, yend = 1.5),arrow = arrow(length = unit(0.1, "cm")))+
  geom_label(aes(label="X", x=1500, y=1.7)) +
  
  geom_segment(aes(x = 1667, y = 2, xend = 2337, yend = 2),arrow = arrow(length = unit(0.1, "cm"))) + 
  geom_label(aes(label="C", x=2000, y=2.2)) +
  
  geom_segment(aes(x = 2169, y = 3, xend = 3494, yend = 3)) +
  geom_label(aes(label="P", x=3100, y=3.2)) +
  
  geom_segment(aes(x = 1, y = 3, xend = 1482, yend = 3),arrow = arrow(length = unit(0.1, "cm"))) +
  geom_label(aes(label="P", x=500, y=3.2))
g1

```

#### Compatibility matrix for bats HBV

```{r}


RF_bats_matrix = as.matrix(read.table("bats_rdp4_RFmatrix.csv", sep=","))

colnames(RF_bats_matrix) = seq(from = 0, by = 25, length.out = ncol(RF_bats_matrix))
colnames(RF_bats_matrix)[1]=1

rownames(RF_bats_matrix) = seq(from = 0, by = 25, length.out = nrow(RF_bats_matrix))
rownames(RF_bats_matrix)[1]=1

RF_bats_matrix = RF_bats_matrix[,1:(ncol(RF_bats_matrix)-1)][nrow(RF_bats_matrix):1,]

heatmap.2(RF_bats_matrix, Rowv = FALSE, Colv = "Rowv", dendrogram = 'none', col=matlab.like, tracecol=NA, main = "Robinson-Foulds compatibility matrix (window=400,step=25)")
```


#### RMSE matrix for bats HBV

```{r}
bats = read.dna("D:/DATA/Hepadnaviridae/bats.fas", format="fasta")
rmse_df_bats = plot_rmse(bats,25, 400,"pdist","pairwise")

heatmap.2(as.matrix(rmse_df_bats[nrow(rmse_df_bats):1,]),Rowv = FALSE, Colv = "Rowv", dendrogram = 'none',col=matlab.like, main="bat HBV RMSE matrix (window=400,step=25)",tracecol=NA)

```



#### Control pairwise distance plot for bats

```{r}
contr = plot_control(bats)
contr[[1]]
```

#### 1-600 nt vs 600-1000 nt

```{r}
l = plot_dist_test(bats, 1,600,600,1000)
l[[1]]
```


```{r fig.width = 8, fig.height = 8}

plot_host_pie(as.matrix(l[[2]]),0.04, 0.1, as.matrix(l[[3]]), 0, 0.05)

```

#### 1-700 nt vs 1600-2200 nt

```{r fig.width = 8, fig.height = 8}
l = plot_dist_test(bats, 1,700,1600,2200)
l[[1]]
plot_host_pie(as.matrix(l[[2]]),0.04, 0.1, as.matrix(l[[3]]), 0, 0.08)



```

#### 800-1200 nt vs 1600-2000 nt

```{r}
l = plot_dist_test(bats, 800,1200,1600,2200)
l[[1]]
```


```{r fig.width = 8, fig.height = 8}

plot_host_pie(as.matrix(l[[2]]),0.05, 0.1, as.matrix(l[[3]]), 0, 0.05)


```


#### 1-400 nt vs 2700-3400 nt

```{r}
l = plot_dist_test(bats, 1,400,2700,3400)
l[[1]]

```
```{r  fig.width = 9, fig.height = 9}
plot_host_pie(as.matrix(l[[2]]),0.05, 0.1, as.matrix(l[[3]]), 0, 0.1)
plot_host_pie(as.matrix(l[[2]]),0.24, 0.3, as.matrix(l[[3]]), 0.4, 0.65)
```


#### 700-1100nt vs 2700-3100nt

```{r}
l = plot_dist_test(bats, 1300,1700,2700,3100)
l[[1]]

```

```{r  fig.width = 9, fig.height = 9}
plot_host_pie(as.matrix(l[[2]]),0.4, 0.6, as.matrix(l[[3]]), 0.4, 0.6)
```

#### 1300-1700nt vs 2700-3100nt

```{r}
l = plot_dist_test(bats, 1300,1700,2700,3100)
l[[1]]

```
```{r  fig.width = 9, fig.height = 9}
plot_host_pie(as.matrix(l[[2]]),0.4, 0.6, as.matrix(l[[3]]), 0.4, 0.6)
```



